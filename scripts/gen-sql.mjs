import { readFile, writeFile } from 'node:fs/promises';
import path from 'node:path';
import { fileURLToPath } from 'node:url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const rootDir = path.resolve(__dirname, '..');
const schemaPath = path.join(rootDir, 'schema', 'schema.json');
const outputPath = path.join(rootDir, 'supabase-schema.sql');

const QUOTE = (identifier) => `"${identifier.replace(/"/g, '""')}"`;

const loadSchema = async () => {
  const raw = await readFile(schemaPath, 'utf8');
  const schema = JSON.parse(raw);
  if (!schema || typeof schema !== 'object') {
    throw new Error('Schema file must export an object.');
  }
  if (!Array.isArray(schema.tables)) {
    throw new Error('Schema must include a "tables" array.');
  }
  return schema;
};

const renderColumn = (column) => {
  const parts = [QUOTE(column.name), column.type];
  if (column.nullable === false) {
    parts.push('not null');
  }
  if (column.default) {
    parts.push('default', column.default);
  }
  return parts.join(' ');
};

const renderPrimaryKey = (primaryKey) => {
  if (!primaryKey || primaryKey.length === 0) {
    return null;
  }
  const cols = primaryKey.map((col) => QUOTE(col)).join(', ');
  return `primary key (${cols})`;
};

const renderUnique = (unique) => {
  if (!unique || unique.length === 0) {
    return [];
  }
  return unique.map((constraint) => {
    const cols = constraint.columns.map((col) => QUOTE(col)).join(', ');
    const constraintName = constraint.name ? QUOTE(constraint.name) + ' ' : '';
    return `${constraintName}unique (${cols})`;
  });
};

const renderCheckConstraints = (checks) => {
  if (!checks || checks.length === 0) {
    return [];
  }
  return checks.map((constraint) => {
    const constraintName = constraint.name ? QUOTE(constraint.name) + ' ' : '';
    return `${constraintName}check (${constraint.expression})`;
  });
};

const renderForeignKeys = (table) => {
  if (!Array.isArray(table.foreignKeys) || table.foreignKeys.length === 0) {
    return [];
  }
  return table.foreignKeys.map((fk) => {
    const cols = fk.columns.map((col) => QUOTE(col)).join(', ');
    const refCols = fk.references.columns.map((col) => QUOTE(col)).join(', ');
    const parts = [
      `foreign key (${cols}) references ${fk.references.schema ? QUOTE(fk.references.schema) + '.' : ''}${QUOTE(fk.references.table)} (${refCols})`
    ];
    if (fk.onDelete) {
      parts.push(`on delete ${fk.onDelete}`);
    }
    if (fk.onUpdate) {
      parts.push(`on update ${fk.onUpdate}`);
    }
    return parts.join(' ');
  });
};

const renderTable = (table) => {
  const columnLines = table.columns.map((column) => `  ${renderColumn(column)}`);
  const constraintLines = [];
  const pk = renderPrimaryKey(table.primaryKey);
  if (pk) {
    constraintLines.push(`  ${pk}`);
  }
  renderUnique(table.uniqueConstraints).forEach((line) => {
    constraintLines.push(`  ${line}`);
  });
  renderCheckConstraints(table.checkConstraints).forEach((line) => {
    constraintLines.push(`  ${line}`);
  });
  renderForeignKeys(table).forEach((line) => {
    constraintLines.push(`  ${line}`);
  });
  const allLines = [...columnLines, ...constraintLines].join(',\n');
  const tableName = table.schema ? `${QUOTE(table.schema)}.${QUOTE(table.name)}` : `${QUOTE('public')}.${QUOTE(table.name)}`;
  return `create table if not exists ${tableName} (\n${allLines}\n);`;
};

const renderIndexes = (table) => {
  if (!Array.isArray(table.indexes) || table.indexes.length === 0) {
    return [];
  }
  return table.indexes.map((index) => {
    const unique = index.unique ? 'unique ' : '';
    const columns = index.columns.map((col) => QUOTE(col)).join(', ');
    const indexName = index.name ? QUOTE(index.name) : QUOTE(`${table.name}_${index.columns.join('_')}_idx`);
    const tableName = table.schema ? `${QUOTE(table.schema)}.${QUOTE(table.name)}` : `${QUOTE('public')}.${QUOTE(table.name)}`;
    return `create ${unique}index if not exists ${indexName} on ${tableName} (${columns});`;
  });
};

const renderComments = (table) => {
  const statements = [];
  if (table.description) {
    const tableName = table.schema ? `${QUOTE(table.schema)}.${QUOTE(table.name)}` : `${QUOTE('public')}.${QUOTE(table.name)}`;
    statements.push(`comment on table ${tableName} is ${JSON.stringify(table.description)};`);
  }
  for (const column of table.columns) {
    if (column.description) {
      const tableName = table.schema ? `${QUOTE(table.schema)}.${QUOTE(table.name)}` : `${QUOTE('public')}.${QUOTE(table.name)}`;
      statements.push(`comment on column ${tableName}.${QUOTE(column.name)} is ${JSON.stringify(column.description)};`);
    }
  }
  return statements;
};

const buildSql = (schema) => {
  const lines = [
    '-- ⚠️ AUTOGENERATED FILE. DO NOT EDIT DIRECTLY.',
    '-- Generated by scripts/gen-sql.mjs',
    ''
  ];
  if (schema.tables.length === 0) {
    lines.push('-- No tables defined.');
  }
  for (const table of schema.tables) {
    lines.push(renderTable(table));
    lines.push('');
    renderIndexes(table).forEach((stmt) => {
      lines.push(stmt);
    });
    if (table.indexes && table.indexes.length > 0) {
      lines.push('');
    }
    renderComments(table).forEach((stmt) => {
      lines.push(stmt);
    });
    if (table.columns.some((column) => column.description)) {
      lines.push('');
    }
  }
  return lines.join('\n').trimEnd() + '\n';
};

const main = async () => {
  const schema = await loadSchema();
  const sql = buildSql(schema);
  await writeFile(outputPath, sql);
};

main().catch((error) => {
  console.error(error);
  process.exitCode = 1;
});
